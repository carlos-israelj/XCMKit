"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFactoryDependencies = handleFactoryDependencies;
const ethers_1 = require("ethers");
const fs_1 = __importDefault(require("fs"));
const fast_glob_1 = require("fast-glob");
const chalk_1 = __importDefault(require("chalk"));
const polkadot_api_1 = require("polkadot-api");
const web_1 = require("polkadot-api/ws-provider/web");
const path_1 = __importDefault(require("path"));
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const MAGIC_DEPLOY_ADDRESS = "0x6d6f646c70792f70616464720000000000000000";
const ALICE_ACCOUNT_SS58 = "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY";
const MAX_U_128 = BigInt("0xffffffffffffffffffffffffffffffff"); // 2^128 - 1
/**
 * Uploads factory dependencies (child contract bytecodes) if not already deployed.
 */
async function handleFactoryDependencies(pathToArtifacts, ethRpcUrl, polkadotRpcUrl, accounts) {
    // get last build info file
    const files = await (0, fast_glob_1.glob)(`${pathToArtifacts}/build-info/*.json`);
    if (files.length === 0)
        return;
    files.sort((a, b) => fs_1.default.statSync(b).mtimeMs - fs_1.default.statSync(a).mtimeMs);
    const lastBuildInfo = JSON.parse(fs_1.default.readFileSync(files[0], "utf8"));
    for (const [_, contracts] of Object.entries(lastBuildInfo.output.contracts)) {
        for (const [parentContractName, artifact] of Object.entries(contracts)) {
            const factoryDependencies = artifact.factoryDependencies;
            if (!factoryDependencies || Object.keys(factoryDependencies).length === 0)
                continue;
            const ethProvider = new ethers_1.JsonRpcProvider(ethRpcUrl);
            const wallet = new ethers_1.Wallet(getPrivateKey(accounts), ethProvider);
            const dotProvider = (0, web_1.getWsProvider)((0, utils_1.getPolkadotRpcUrl)(ethRpcUrl, polkadotRpcUrl));
            const client = (0, polkadot_api_1.createClient)(dotProvider);
            const api = client.getUnsafeApi();
            const unsafeToken = await api.runtimeToken;
            for (const [hash, identifier] of Object.entries(factoryDependencies)) {
                // check if code hash already exists
                const code = await api.query.Revive.PristineCode.getValue(polkadot_api_1.Binary.fromHex(hash));
                if (code)
                    continue;
                const [sourcePath, childContractName] = identifier.split(":");
                console.info(chalk_1.default.yellow(`Uploading factory dependency in ${parentContractName}...`));
                // get the bytecode from the artifact
                const artifactPath = path_1.default.join(pathToArtifacts, sourcePath, `${childContractName}.json`);
                const artifact = JSON.parse(fs_1.default.readFileSync(artifactPath, "utf8"));
                const bytecode = artifact.bytecode?.object ?? artifact.bytecode;
                // estimate the storage deposit limit
                const uploadCodeApi = await api.apis.ReviveApi.upload_code(ALICE_ACCOUNT_SS58, // not relevant
                polkadot_api_1.Binary.fromHex(bytecode), MAX_U_128);
                // upload the bytecode through the ETH RPC
                const call = api.tx.Revive.upload_code({
                    code: polkadot_api_1.Binary.fromHex(bytecode),
                    storage_deposit_limit: uploadCodeApi.value.deposit,
                });
                const payload = call.getEncodedData(unsafeToken);
                const tx = await wallet.sendTransaction({
                    to: MAGIC_DEPLOY_ADDRESS,
                    data: payload.asHex(),
                });
                await tx.wait();
            }
            client.destroy();
        }
    }
}
function getPrivateKey(accounts) {
    if (Array.isArray(accounts)) {
        if (accounts.length === 0)
            throw new errors_1.PolkadotNodePluginError("Accounts array is empty.");
        if (typeof accounts[0] === "string")
            return accounts[0];
        return accounts[0].privateKey;
    }
    throw new errors_1.PolkadotNodePluginError("Could not retrieve private key.");
}
//# sourceMappingURL=factory-support.js.map