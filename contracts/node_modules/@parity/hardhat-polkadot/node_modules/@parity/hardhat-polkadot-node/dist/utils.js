"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARITYPR_DOCKER_REGISTRY = void 0;
exports.constructCommandArgs = constructCommandArgs;
exports.isPortAvailable = isPortAvailable;
exports.getAvailablePort = getAvailablePort;
exports.adjustTaskArgsForPort = adjustTaskArgsForPort;
exports.getNetworkConfig = getNetworkConfig;
exports.configureNetwork = configureNetwork;
exports.startServer = startServer;
exports.getLatestImageName = getLatestImageName;
exports.getDockerSocketPath = getDockerSocketPath;
exports.waitForServiceToBeReady = waitForServiceToBeReady;
exports.getPolkadotRpcUrl = getPolkadotRpcUrl;
const axios_1 = __importDefault(require("axios"));
const net_1 = __importDefault(require("net"));
const construction_1 = require("hardhat/internal/core/providers/construction");
const lru_cache_1 = require("lru-cache");
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const rpc_server_1 = require("./rpc-server");
const errors_1 = require("./errors");
const constants_1 = require("./constants");
exports.PARITYPR_DOCKER_REGISTRY = "https://registry.hub.docker.com/v2/repositories/paritypr/";
const DOCKER_SOCKET_DEFAULT_PATH = "/var/run/docker.sock";
const cache = new lru_cache_1.LRUCache({
    max: 50,
    ttl: 1000 * 60 * 5,
});
function constructCommandArgs(args, cliCommands) {
    const nodeCommands = [];
    const adapterCommands = [];
    if (cliCommands && Object.values(cliCommands).find((v) => v !== undefined)) {
        if (cliCommands.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${cliCommands.fork}`);
        }
        else if (cliCommands.nodeBinaryPath) {
            nodeCommands.push(cliCommands.nodeBinaryPath);
        }
        if (cliCommands.rpcPort) {
            if (cliCommands.fork) {
                nodeCommands.push(`--port=${cliCommands.rpcPort}`);
            }
            else {
                nodeCommands.push(`--rpc-port=${cliCommands.rpcPort}`);
            }
            nodeCommands.push(`--rpc-port=${cliCommands.rpcPort}`);
            adapterCommands.push(`--node-rpc-url=ws://localhost:${cliCommands.rpcPort}`);
        }
        else {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (cliCommands.adapterPort && cliCommands.adapterPort !== cliCommands.rpcPort) {
            adapterCommands.push(`--rpc-port=${cliCommands.adapterPort}`);
        }
        else if (cliCommands.adapterPort && cliCommands.adapterPort === cliCommands.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (cliCommands.fork) {
            nodeCommands.push(`--build-block-mode=${cliCommands.buildBlockMode || "Instant"}`);
        }
        if (cliCommands.dev) {
            adapterCommands.push("--dev");
            if (cliCommands.nodeBinaryPath && !cliCommands.fork) {
                nodeCommands.push("--dev");
            }
        }
    }
    if (args && Object.values(args).find((v) => v !== undefined)) {
        if (args.forking && !cliCommands?.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${args.forking.url}`);
        }
        else if (args.nodeCommands?.nodeBinaryPath && !cliCommands?.nodeBinaryPath) {
            nodeCommands.push(args.nodeCommands?.nodeBinaryPath);
        }
        if (args.nodeCommands?.rpcPort && !cliCommands?.rpcPort) {
            if (args.forking && !cliCommands?.fork) {
                nodeCommands.push(`--port=${args.nodeCommands.rpcPort}`);
            }
            else {
                nodeCommands.push(`--rpc-port=${args.nodeCommands.rpcPort}`);
            }
            adapterCommands.push(`--node-rpc-url=ws://localhost:${args.nodeCommands.rpcPort}`);
        }
        else if (!cliCommands?.rpcPort) {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort !== args.nodeCommands?.rpcPort) {
            adapterCommands.push(`--rpc-port=${args.adapterCommands?.adapterPort}`);
        }
        else if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort === args.nodeCommands?.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort === args.nodeCommands?.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (args.forking && !cliCommands?.buildBlockMode) {
            nodeCommands.push(`--build-block-mode=${args.adapterCommands?.buildBlockMode || "Instant"}`);
        }
        if (args.nodeCommands?.nodeBinaryPath && args.nodeCommands?.consensus) {
            if (args.nodeCommands.consensus.seal === "Manual") {
                nodeCommands.push(`--consensus=manual-seal-${args.nodeCommands.consensus.period || 50}`);
            }
            else {
                nodeCommands.push(`--consensus=${(args.nodeCommands.consensus.seal || "None").toLowerCase()}`);
            }
        }
        if (args.nodeCommands?.nodeBinaryPath &&
            args.nodeCommands.dev &&
            !cliCommands?.dev &&
            !args.forking) {
            nodeCommands.push(`--dev`);
        }
        if (args.adapterCommands?.dev && !cliCommands?.dev) {
            adapterCommands.push("--dev");
        }
    }
    return {
        nodeCommands,
        adapterCommands,
    };
}
async function isPortAvailableForIP(port, ip) {
    return new Promise((resolve) => {
        const tester = net_1.default
            .createServer()
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .once("error", (err) => resolve(err.code !== "EADDRINUSE"))
            .once("listening", () => tester.close(() => resolve(true)))
            .listen(port, ip);
    });
}
async function isPortAvailable(port) {
    const availableIPv4 = await isPortAvailableForIP(port, "0.0.0.0");
    const availableIPv6 = await isPortAvailableForIP(port, "::");
    return availableIPv4 && availableIPv6;
}
async function getAvailablePort(startPort, maxAttempts) {
    let currentPort = startPort;
    for (let i = 0; i < maxAttempts; i++) {
        if (await isPortAvailable(currentPort)) {
            return currentPort;
        }
        currentPort++;
    }
    throw new errors_1.PolkadotNodePluginError("Couldn't find an available port after several attempts");
}
function adjustTaskArgsForPort(taskArgs, currentPort) {
    const portArg = "--port";
    const portArgIndex = taskArgs.indexOf(portArg);
    if (portArgIndex !== -1) {
        if (portArgIndex + 1 < taskArgs.length) {
            taskArgs[portArgIndex + 1] = `${currentPort}`;
        }
        else {
            throw new errors_1.PolkadotNodePluginError("Invalid task arguments: --port provided without a following port number.");
        }
    }
    else {
        taskArgs.push(portArg, `${currentPort}`);
    }
    return taskArgs;
}
function getNetworkConfig(url, chainId) {
    return {
        accounts: "remote",
        gas: constants_1.NETWORK_GAS.AUTO,
        gasPrice: constants_1.NETWORK_GAS_PRICE.AUTO,
        gasMultiplier: 1,
        httpHeaders: {},
        timeout: 20000,
        url,
        ethNetwork: constants_1.NETWORK_ETH.LOCALHOST,
        chainId: chainId || 420420421,
    };
}
async function configureNetwork(config, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
network, port) {
    const url = `${constants_1.BASE_URL}:${port}`;
    const payload = {
        jsonrpc: "2.0",
        method: constants_1.RPC_ENDPOINT_PATH,
        params: [],
        id: 1,
    };
    let chainId = 0;
    try {
        const response = await axios_1.default.post(url, payload);
        if (response.status == 200) {
            chainId = parseInt(response.data.result);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (_e) {
        // If it fails, it will just try again
    }
    network.name = constants_1.POLKADOT_TEST_NODE_NETWORK_NAME;
    network.config = getNetworkConfig(url, chainId);
    config.networks[network.name] = network.config;
    network.provider = await (0, construction_1.createProvider)(config, network.name);
}
async function startServer(commands, nodePath, adapterPath) {
    const currentNodePort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.NODE_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const currentAdapterPort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.ETH_RPC_ADAPTER_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const updatedCommands = Object.assign({}, commands, {
        nodeCommands: { port: currentNodePort },
        adapterCommands: { adapterPort: currentAdapterPort },
    });
    const commandArgs = constructCommandArgs(updatedCommands);
    return {
        commandArgs,
        server: (0, rpc_server_1.createRpcServer)({
            docker: commands.docker,
            nodePath,
            adapterPath: adapterPath || commands.adapterCommands?.adapterBinaryPath,
            isForking: commands.forking?.enabled,
        }),
        port: currentAdapterPort,
    };
}
/**
 * This function retrieves a list of the latest images available in the Docker registry
 * sortes them from newest to oldest, and returns the newest one, in order to be used by the DockerServer.
 */
async function getLatestImageName(containerName) {
    const cachedResult = cache.get(containerName);
    if (cachedResult) {
        return cachedResult;
    }
    const url = `${exports.PARITYPR_DOCKER_REGISTRY}${containerName}/tags?page_size=10`;
    const imageResponse = await axios_1.default.get(url, {
        timeout: 5000,
        responseType: "json",
    });
    if (imageResponse.status == 200) {
        const imageList = imageResponse.data;
        imageList.results
            .sort(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (a, b) => new Date(b.last_updated).getTime() - new Date(a.last_updated).getTime())
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map((tag) => tag.name);
        const latestImageName = imageList.results[0].name;
        if (latestImageName) {
            cache.set(containerName, latestImageName);
        }
        return latestImageName;
    }
    else {
        throw new Error(`Failed to fetch tags: ${imageResponse.statusText}`);
    }
}
function getDockerSocketPath(docker) {
    const customDockerSocketPath = typeof docker === "string" ? docker : undefined;
    const dockerSocketPath = customDockerSocketPath ||
        (fs_1.default.existsSync(path_1.default.join(os_1.default.homedir(), ".docker", "run", "docker.sock"))
            ? path_1.default.join(os_1.default.homedir(), ".docker", "run", "docker.sock")
            : DOCKER_SOCKET_DEFAULT_PATH);
    return dockerSocketPath;
}
async function waitForServiceToBeReady(port, payload, maxAttempts) {
    let attempts = 0;
    let waitTime = 1000;
    const backoffFactor = 2;
    const maxWaitTime = 30000;
    const endpoint = `${constants_1.BASE_URL}:${port}`;
    while (attempts < maxAttempts) {
        try {
            const response = await axios_1.default.post(endpoint, payload);
            if (response.status == 200) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (_e) {
            // If it fails, it will just try again
        }
        attempts++;
        await new Promise((r) => setTimeout(r, waitTime));
        waitTime = Math.min(waitTime * backoffFactor, maxWaitTime);
    }
    throw new errors_1.PolkadotNodePluginError("Server didn't respond after multiple attempts");
}
function getPolkadotRpcUrl(ethRpcUrl, polkadotRpcUrl) {
    // Case 1: Explicit config
    if (polkadotRpcUrl)
        return polkadotRpcUrl;
    // Case 2: Infer from ETH RPC URL
    if (ethRpcUrl) {
        const url = ethRpcUrl.replace(/^https?:\/\//, "");
        if (url in constants_1.ETH_RPC_TO_SUBSTRATE_RPC) {
            return constants_1.ETH_RPC_TO_SUBSTRATE_RPC[url];
        }
    }
    throw new errors_1.PolkadotNodePluginError("Factory dependencies found. Please configure `polkadotUrl` in hardhat.config. See example https://github.com/paritytech/hardhat-polkadot/blob/79f3398708eab4f8b27e9ba087d7f2e59d83e796/examples/all-polkavm-networks/hardhat.config.ts#L53");
}
//# sourceMappingURL=utils.js.map