"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateNodeService = void 0;
const child_process_1 = require("child_process");
const chalk_1 = __importDefault(require("chalk"));
const run_container_1 = require("run-container");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const index_1 = require("./index");
const SUBSTRATE_NODE_CONTAINER_NAME = "substrate";
class SubstrateNodeService extends index_1.Service {
    port;
    constructor(commandArgs = [], blockProcess = true) {
        super(commandArgs.slice(1), blockProcess);
        const portArg = commandArgs.find((arg) => arg.startsWith("--rpc-port="));
        this.port = portArg ? parseInt(portArg.split("=")[1], 10) : constants_1.NODE_START_PORT;
    }
    async from_binary(pathToBinary) {
        return new Promise((resolve, reject) => {
            if (this.blockProcess) {
                console.info(chalk_1.default.green(`Starting server at 127.0.0.1:${this.port}`));
                console.info(chalk_1.default.green(`Running command: ${pathToBinary} ${this.commandArgs.join(" ")}`));
            }
            let stdioConfig = "inherit";
            if (!this.blockProcess) {
                stdioConfig = ["ignore", "ignore", "ignore"];
            }
            this.process = (0, child_process_1.spawn)(pathToBinary, this.commandArgs, { stdio: stdioConfig });
            this.process.on("error", this._handleOnError("server", reject));
            this.process.on("exit", this._handleOnExit("server"));
            if (!this.blockProcess) {
                resolve();
            }
        });
    }
    async from_docker(docker) {
        // TODO: use latestImage once it is more stable
        // const imageTag = await getLatestImageName(SUBSTRATE_NODE_CONTAINER_NAME)
        const imageTag = "master-a209e590";
        const container = docker.getContainer(SUBSTRATE_NODE_CONTAINER_NAME);
        await container
            .inspect()
            .then(() => container.remove({ force: true }))
            .catch(() => { });
        this.container = await (0, run_container_1.runSimple)({
            name: SUBSTRATE_NODE_CONTAINER_NAME,
            image: `paritypr/substrate:${imageTag}`,
            autoRemove: true,
            ports: {
                [`${this.port}/tcp`]: `${this.port}`,
            },
            cmd: ["--dev", "--rpc-port", `${this.port}`, "--unsafe-rpc-external"],
            verbose: true,
        });
        ["exit", "SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM"].forEach((e) => {
            process.on(e, async () => await this.container.remove({ force: true }));
        });
        if (this.blockProcess) {
            // show docker logs in client console
            const stream = await this.container.attach({
                stream: true,
                stdout: true,
                stderr: true,
            });
            this.container.modem.demuxStream(stream, process.stdout, process.stderr);
            await this.container.wait();
        }
    }
    async stop() {
        if (this.process && !this.process.killed) {
            this.process.kill();
        }
        if (this.container) {
            await this.container.remove({ force: true });
        }
    }
    static async waitForNodeToBeReady(port, maxAttempts = 20) {
        const payload = {
            jsonrpc: "2.0",
            method: "state_getRuntimeVersion",
            params: [],
            id: 1,
        };
        await (0, utils_1.waitForServiceToBeReady)(port, payload, maxAttempts);
    }
}
exports.SubstrateNodeService = SubstrateNodeService;
//# sourceMappingURL=substrate-node.js.map