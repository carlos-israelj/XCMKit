"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthRpcService = void 0;
const child_process_1 = require("child_process");
const chalk_1 = __importDefault(require("chalk"));
const run_container_1 = require("run-container");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const index_1 = require("./index");
const ADAPTER_CONTAINER_NAME = "eth-rpc";
class EthRpcService extends index_1.Service {
    port;
    constructor(commandArgs = [], blockProcess = true) {
        super(commandArgs, blockProcess);
        const portArg = this.commandArgs.find((arg) => arg.startsWith("--rpc-port="));
        this.port = portArg ? parseInt(portArg.split("=")[1], 10) : constants_1.ETH_RPC_ADAPTER_START_PORT;
    }
    async from_binary(pathToBinary) {
        return new Promise((resolve, reject) => {
            let stdioConfig = "inherit";
            if (!this.blockProcess) {
                stdioConfig = ["ignore", "ignore", "ignore"];
            }
            if (this.blockProcess) {
                console.info(chalk_1.default.green(`Starting the Eth RPC Adapter at 127.0.0.1:${this.port}`));
                console.info(chalk_1.default.green(`Running command: ${pathToBinary} ${this.commandArgs.join(" ")}`));
            }
            this.process = (0, child_process_1.spawn)(pathToBinary, this.commandArgs, { stdio: stdioConfig });
            this.process.on("error", this._handleOnError("Eth RPC Adapter", reject));
            this.process.on("exit", this._handleOnExit("Eth RPC Adapter"));
            if (!this.blockProcess) {
                resolve();
            }
        });
    }
    async from_docker(docker, nodePort) {
        // TODO: use latestImage once it is more stable
        // const imageTag = await getLatestImageName(ADAPTER_CONTAINER_NAME)
        const imageTag = "master-87a8fb03";
        const container = docker.getContainer(ADAPTER_CONTAINER_NAME);
        await container
            .inspect()
            .then(() => container.remove({ force: true }))
            .catch(() => { });
        this.container = await (0, run_container_1.run)({
            Image: `paritypr/eth-rpc:${imageTag}`,
            name: ADAPTER_CONTAINER_NAME,
            HostConfig: {
                NetworkMode: process.env.CI ? "host" : undefined,
                AutoRemove: true,
                PortBindings: process.env.CI
                    ? undefined
                    : {
                        [`${this.port}/tcp`]: [{ HostPort: `${this.port}` }],
                    },
            },
            ExposedPorts: {
                [`${this.port}/tcp`]: {},
            },
            Cmd: [
                "--dev",
                "--rpc-port",
                `${this.port}`,
                "--node-rpc-url",
                `ws://${constants_1.NODE_RPC_URL_BASE_URL}:${nodePort}`,
                "--unsafe-rpc-external",
                "--rpc-cors",
                "all",
            ],
            Tty: false,
            Env: [],
        });
        ["exit", "SIGINT", "SIGUSR1", "SIGUSR2", "uncaughtException", "SIGTERM"].forEach((e) => {
            process.on(e, async () => await this.container.remove({ force: true }).then(() => process.exit(0)));
        });
        if (this.blockProcess) {
            console.info(chalk_1.default.green(`Starting the Eth RPC Adapter at 127.0.0.1:${this.port}`));
            await this.container.wait();
        }
    }
    async stop() {
        if (this.process && !this.process.killed) {
            this.process.kill();
        }
        if (this.container) {
            await this.container.remove({ force: true });
        }
    }
    static async waitForEthRpcToBeReady(port, maxAttempts = 20) {
        const payload = {
            jsonrpc: "2.0",
            method: constants_1.RPC_ENDPOINT_PATH,
            params: [],
            id: 1,
        };
        await (0, utils_1.waitForServiceToBeReady)(port, payload, maxAttempts);
    }
}
exports.EthRpcService = EthRpcService;
//# sourceMappingURL=eth-rpc.js.map