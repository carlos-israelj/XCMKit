{"version":3,"file":"submit-fns.mjs","sources":["../../../src/tx/submit-fns.ts"],"sourcesContent":["import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  catchError,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  merge,\n  mergeMap,\n  of,\n  reduce,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const validate$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    mergeMap((blocks) => {\n      let bestBlocks: string[] = []\n      return blocks.finalizedRuntime.runtime.pipe(\n        map((r) => r.getMortalityFromTx(tx)),\n        catchError(() => of({ mortal: false as const })),\n        map((x) => {\n          const { best, finalized } = blocks\n\n          // before we start doing async stuff, we must \"take a picture\"\n          // of the current lineage of best-blocks\n          let current = best\n          while (current !== finalized) {\n            bestBlocks.push(current)\n            current = blocks.blocks.get(current)!.parent\n          }\n          bestBlocks.push(finalized)\n\n          if (!x.mortal) return [finalized, best]\n\n          const { phase, period } = x\n          const bestBlock = blocks.blocks.get(best)!\n          const topNumber = bestBlock.number\n          const txBlockNumber =\n            Math.floor((topNumber - phase) / period) * period + phase\n\n          let result = [blocks.blocks.get(blocks.finalized)!]\n          while (result.length && result[0].number < txBlockNumber) {\n            result = result\n              .flatMap((x) => [...x.children])\n              .map((x) => blocks.blocks.get(x)!)\n              .filter(Boolean)\n          }\n          return (result.length ? result : [bestBlock]).map((x) => x.hash)\n        }),\n        mergeMap((toCheck) =>\n          merge(\n            ...[...new Set(toCheck)].map((at) =>\n              chainHead\n                .validateTx$(at, tx)\n                .pipe(map((result) => ({ at, result }))),\n            ),\n          ),\n        ),\n        takeWhile(({ result }) => !result.success, true),\n        reduce(\n          (acc, curr) => [...acc, curr],\n          [] as { at: string; result: ResultPayload<any, any> }[],\n        ),\n        map((results) => {\n          const badOnes = new Map(\n            results\n              .filter(({ result }) => !result.success)\n              .map((x) => [x.at, x.result]),\n          )\n          if (badOnes.size < results.length) return null\n\n          throw new InvalidTxError(\n            badOnes.get(\n              // there is a possible, but very unlikely, race-condition in which:\n              // we have received a new block that is about to be flagged as best,\n              // and that its height is higher than all the others, but the notification\n              // that sets it as best has not arrived yet. In that case, that block wouldn't\n              // be in the lineage of the best-blocks, but then it would be the only one in the list of `badOnes`\n              bestBlocks.find((x) => badOnes.has(x)) ?? [...badOnes.keys()][0],\n            )!.value,\n          )\n        }),\n        filter(Boolean),\n      )\n    }),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  _at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n"],"names":["x"],"mappings":"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"}