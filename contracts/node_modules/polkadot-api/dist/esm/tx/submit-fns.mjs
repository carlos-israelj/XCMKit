import { Binary, Blake2256 } from '@polkadot-api/substrate-bindings';
import { lastValueFrom, take, mergeMap, map, catchError, of, merge, takeWhile, reduce, filter, Observable, concat, EMPTY, distinctUntilChanged } from 'rxjs';
import '@polkadot-api/observable-client';
import '../utils/shareLatest.mjs';
import { toHex, fromHex } from '@polkadot-api/utils';
import { continueWith } from '../utils/continue-with.mjs';
import 'rxjs/operators';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "" , value);
const hashFromTx = (tx) => toHex(Blake2256(fromHex(tx)));
const computeState = (analized$, blocks$) => new Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && latestState?.found && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (analyzed.found.validity?.success === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(distinctUntilChanged((a, b) => a === b));
const getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
class InvalidTxError extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value) => {
          if (typeof value === "bigint") return value.toString();
          return value instanceof Binary ? value.asHex() : value;
        },
        2
      )
    );
    __publicField(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
}
const submit$ = (chainHead, broadcastTx$, tx, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const validate$ = chainHead.pinnedBlocks$.pipe(
    take(1),
    mergeMap((blocks) => {
      let bestBlocks = [];
      return blocks.finalizedRuntime.runtime.pipe(
        map((r) => r.getMortalityFromTx(tx)),
        catchError(() => of({ mortal: false })),
        map((x) => {
          const { best, finalized } = blocks;
          let current = best;
          while (current !== finalized) {
            bestBlocks.push(current);
            current = blocks.blocks.get(current).parent;
          }
          bestBlocks.push(finalized);
          if (!x.mortal) return [finalized, best];
          const { phase, period } = x;
          const bestBlock = blocks.blocks.get(best);
          const topNumber = bestBlock.number;
          const txBlockNumber = Math.floor((topNumber - phase) / period) * period + phase;
          let result = [blocks.blocks.get(blocks.finalized)];
          while (result.length && result[0].number < txBlockNumber) {
            result = result.flatMap((x2) => [...x2.children]).map((x2) => blocks.blocks.get(x2)).filter(Boolean);
          }
          return (result.length ? result : [bestBlock]).map((x2) => x2.hash);
        }),
        mergeMap(
          (toCheck) => merge(
            ...[...new Set(toCheck)].map(
              (at) => chainHead.validateTx$(at, tx).pipe(map((result) => ({ at, result })))
            )
          )
        ),
        takeWhile(({ result }) => !result.success, true),
        reduce(
          (acc, curr) => [...acc, curr],
          []
        ),
        map((results) => {
          const badOnes = new Map(
            results.filter(({ result }) => !result.success).map((x) => [x.at, x.result])
          );
          if (badOnes.size < results.length) return null;
          throw new InvalidTxError(
            badOnes.get(
              // there is a possible, but very unlikely, race-condition in which:
              // we have received a new block that is about to be flagged as best,
              // and that its height is higher than all the others, but the notification
              // that sets it as best has not arrived yet. In that case, that block wouldn't
              // be in the lineage of the best-blocks, but then it would be the only one in the list of `badOnes`
              bestBlocks.find((x) => badOnes.has(x)) ?? [...badOnes.keys()][0]
            ).value
          );
        }),
        filter(Boolean)
      );
    })
  );
  const track$ = new Observable((observer) => {
    const subscription = chainHead.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(
    map((x) => {
      if (!x.found)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: x.validity?.success !== false
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          number: x.number,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return concat(
    emitSign ? of(getTxEvent("signed", {})) : EMPTY,
    validate$,
    of(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? of(getTxEvent("finalized", rest)) : EMPTY
      )
    )
  );
};
const submit = async (chainHead, broadcastTx$, transaction, _at) => lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

export { InvalidTxError, submit, submit$ };
//# sourceMappingURL=submit-fns.mjs.map
