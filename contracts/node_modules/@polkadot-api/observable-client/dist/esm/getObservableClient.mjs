import { noop, of } from 'rxjs';
import { getChainHead$ } from './chainHead/chainHead.mjs';
import getBroadcastTx$ from './tx.mjs';
import { getArchive } from './archive/archive.mjs';

const ofNullFn = () => of(null);
const clientCache = /* @__PURE__ */ new Map();
const getObservableClient = (substrateClient, cache = {}) => {
  const { getMetadata, setMetadata } = cache;
  const cached = clientCache.get(substrateClient);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const destroy = () => {
    const cached2 = clientCache.get(substrateClient);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache.delete(substrateClient);
      substrateClient.destroy();
    } else {
      cached2.refCount--;
    }
  };
  let cachedChainhead = null;
  let currentSubscribers = 0;
  let expectedSubscribers = null;
  const client = {
    chainHead$: (_expectedSubscribers) => {
      currentSubscribers++;
      expectedSubscribers || (expectedSubscribers = _expectedSubscribers || 1);
      cachedChainhead || (cachedChainhead = getChainHead$(
        substrateClient.chainHead,
        getMetadata || ofNullFn,
        setMetadata || noop
      ));
      const [result, start] = cachedChainhead;
      if (expectedSubscribers === currentSubscribers) {
        const copiedCurrentSubscribers = currentSubscribers;
        currentSubscribers = 0;
        expectedSubscribers = null;
        cachedChainhead = null;
        start(copiedCurrentSubscribers);
      }
      return result;
    },
    archive: getArchive(substrateClient.archive),
    broadcastTx$: getBroadcastTx$(substrateClient.transaction),
    destroy
  };
  clientCache.set(substrateClient, { client, refCount: 1 });
  return client;
};

export { getObservableClient };
//# sourceMappingURL=getObservableClient.mjs.map
