'use strict';

var rxjs = require('rxjs');
var substrateClient = require('@polkadot-api/substrate-client');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var utils = require('@polkadot-api/utils');
var metadataBuilders = require('@polkadot-api/metadata-builders');

const shareLatest = rxjs.share({
  connector: () => new rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

const concatMapEager = (mapper, concurrent = Infinity) => (source$) => new rxjs.Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = new rxjs.Subscription();
  topSubscription.add(
    source$.subscribe({
      next(outterValue) {
        const idx = mapperIdx++;
        queues.set(
          idx,
          rxjs.defer(() => mapper(outterValue, idx))
        );
        if (innerSubscriptions.size < concurrent) {
          nextSubscription();
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (innerSubscriptions.size === 0) {
          observer.complete();
        }
      }
    })
  );
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

const withDefaultValue = (defaultValue) => (source$) => new rxjs.Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited) observer.next(defaultValue);
  return subscription;
});

const delayUnsubscription = (ms) => (source) => new rxjs.Observable((observer) => {
  const subscription = source.subscribe({
    next(v) {
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  const unsubscribe = () => subscription.unsubscribe();
  return () => {
    Promise.resolve().then(unsubscribe);
  };
});

const CHECK_MORTALITY = "CheckMortality";
const createRuntimeCtx = (metadata, metadataRaw, codeHash) => {
  const lookup = metadataBuilders.getLookupFn(metadata);
  const dynamicBuilder = metadataBuilders.getDynamicBuilder(lookup);
  const events = dynamicBuilder.buildStorage("System", "Events");
  const assetPayment = metadata.extrinsic.signedExtensions.find(
    (x) => x.identifier === "ChargeAssetTxPayment"
  );
  let assetId = null;
  if (assetPayment) {
    const assetTxPayment = lookup(assetPayment.type);
    if (assetTxPayment.type === "struct") {
      const optionalAssetId = assetTxPayment.value.asset_id;
      if (optionalAssetId.type === "option") assetId = optionalAssetId.value.id;
    }
  }
  const extrinsicDecoder = getExtrinsicDecoder(lookup.metadata, dynamicBuilder);
  const getMortalityFromTx = (tx) => {
    const decodedExt = extrinsicDecoder(tx);
    return "extra" in decodedExt && decodedExt.extra[CHECK_MORTALITY] || { mortal: false };
  };
  return {
    assetId,
    metadataRaw,
    codeHash,
    lookup,
    dynamicBuilder,
    events: {
      key: events.keys.enc(),
      dec: events.value.dec
    },
    accountId: substrateBindings.AccountId(dynamicBuilder.ss58Prefix),
    getMortalityFromTx
  };
};
const allBytesDec = substrateBindings.Bytes(Infinity).dec;
const mortalDecoder = substrateBindings.enhanceDecoder(substrateBindings.u16[1], (input) => {
  const period = 2 << input % (1 << 4);
  const factor = Math.max(period >> 12, 1);
  const phase = (input >> 4) * factor;
  return { mortal: true, period, phase };
});
const mortalityDecoder = substrateBindings.createDecoder((value) => {
  const firstByte = substrateBindings.u8.dec(value);
  if (firstByte === 0) return { mortal: false };
  const secondByte = substrateBindings.u8.dec(value);
  return mortalDecoder(Uint8Array.from([firstByte, secondByte]));
});
const getExtrinsicDecoder = (metadata, dynamicBuilder) => {
  const innerExtra = Object.fromEntries(
    metadata.extrinsic.signedExtensions.map(
      (x) => [
        x.identifier,
        x.identifier === CHECK_MORTALITY ? mortalityDecoder : dynamicBuilder.buildDefinition(x.type)[1]
      ]
    )
  );
  let address;
  let signature;
  const { extrinsic } = metadata;
  if ("address" in extrinsic) {
    address = dynamicBuilder.buildDefinition(extrinsic.address)[1];
    signature = dynamicBuilder.buildDefinition(extrinsic.signature)[1];
  } else {
    const params = metadata.lookup[extrinsic.type]?.params;
    const _call = params?.find((v) => v.name === "Call")?.type;
    const addr = params?.find((v) => v.name === "Address")?.type;
    const sig = params?.find((v) => v.name === "Signature")?.type;
    if (_call == null || addr == null || sig == null)
      throw new Error("Call, Address and/or signature not found");
    address = dynamicBuilder.buildDefinition(addr)[1];
    signature = dynamicBuilder.buildDefinition(sig)[1];
  }
  const v4Body = substrateBindings.Struct.dec({
    address,
    signature,
    extra: substrateBindings.Struct.dec(innerExtra),
    callData: allBytesDec
  });
  return substrateBindings.createDecoder((data) => {
    const len = substrateBindings.compactNumber.dec(data);
    const { type, version } = substrateBindings.extrinsicFormat[1](data);
    if (type === "bare")
      return { len, version, type, callData: allBytesDec(data) };
    if (type === "signed") return { len, version, type, ...v4Body(data) };
    const extensionVersion = substrateBindings.u8.dec(data);
    let extraDec;
    if (metadata.version === 16) {
      const extensionsToApply = metadata.extrinsic.signedExtensionsByVersion.find(
        ([x]) => x === extensionVersion
      );
      if (!extensionsToApply) throw new Error("Unexpected extension version");
      extraDec = substrateBindings.Struct.dec(
        Object.fromEntries(
          Object.entries(innerExtra).filter(
            (_, idx) => extensionsToApply[1].includes(idx)
          )
        )
      );
    } else extraDec = substrateBindings.Struct.dec(innerExtra);
    const extra = extraDec(data);
    return {
      len,
      type,
      version,
      extensionVersion,
      extra,
      callData: allBytesDec(data)
    };
  });
};

const versionedArgs = (v) => utils.toHex(substrateBindings.u32.enc(v));
const opaqueBytes = substrateBindings.Bytes();
const optionalOpaqueBytes = substrateBindings.Option(opaqueBytes);
const u32ListDecoder = substrateBindings.Vector(substrateBindings.u32).dec;
const getRawMetadata$ = (call$) => {
  const versions$ = call$("Metadata_metadata_versions", "").pipe(
    rxjs.map(u32ListDecoder),
    rxjs.catchError(() => rxjs.of([14]))
  );
  const versioned$ = (availableVersions) => {
    const [v] = availableVersions.filter((x) => x > 13 && x < 17).sort((a, b) => b - a);
    return v === 14 ? call$("Metadata_metadata", "").pipe(rxjs.map(opaqueBytes.dec)) : call$("Metadata_metadata_at_version", versionedArgs(v)).pipe(
      rxjs.map((x) => optionalOpaqueBytes.dec(x))
    );
  };
  return versions$.pipe(rxjs.mergeMap(versioned$));
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class PendingTaskQueue {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
}
const getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data) return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    let isOperationLimit = false;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        (isOperationLimit = e instanceof substrateClient.OperationLimitError) ? addTask(data, true) : observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (!subscription.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
        onEmptySlot();
      });
    } else if (!isOperationLimit) onEmptySlot();
  };
  const withRecovery = (topPriority = false) => (source$) => new rxjs.Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

class BlockNotPinnedError extends Error {
  constructor(hash, label) {
    super(`Block ${hash} is not pinned (${label})`);
    this.name = "BlockNotPinnedError";
  }
}

const dynamicBlocks = /* @__PURE__ */ new Set(["best", "finalized", null]);
const operable = (source$) => {
  const result = source$.pipe(
    rxjs.catchError(
      (e) => e instanceof substrateClient.OperationInaccessibleError ? rxjs.timer(750).pipe(rxjs.concatMap(() => result)) : rxjs.throwError(() => e)
    )
  );
  return result;
};
const getWithOptionalHash$ = (finalized$, best$, usingBlock) => {
  return (fn) => (hash, ...args) => {
    if (!dynamicBlocks.has(hash))
      return operable(fn(hash, ...args)).pipe(
        usingBlock(hash)
      );
    const hash$ = hash === "best" ? best$ : finalized$;
    const result$ = hash$.pipe(
      rxjs.take(1),
      rxjs.mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),
      rxjs.catchError((e) => {
        return e instanceof BlockNotPinnedError ? result$ : rxjs.throwError(() => e);
      })
    );
    return operable(result$);
  };
};

const fromAbortControllerFn = (fn) => (...args) => new rxjs.Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

const withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

function withStopRecovery(blocks$, fn, label) {
  return (hash, ...args) => {
    const source$ = fn(hash, ...args);
    return new rxjs.Observable((observer) => {
      let sourceSub = null;
      let isSubscribed = false;
      const performSourceSub = () => {
        if (isSubscribed) return;
        isSubscribed = true;
        sourceSub = source$.subscribe({
          next: (v) => observer.next(v),
          error: (e) => observer.error(e),
          complete: () => observer.complete()
        });
        sourceSub.add(() => {
          isSubscribed = false;
          sourceSub = null;
        });
      };
      let isRecovering = false;
      const blockSub = blocks$.subscribe({
        next: (v) => {
          const block = v.blocks.get(hash);
          if (!block) {
            if (isRecovering) {
              observer.error(new BlockNotPinnedError(hash, label));
            }
          } else if (block.recovering) {
            sourceSub?.unsubscribe();
          } else {
            performSourceSub();
          }
          isRecovering = v.recovering;
        },
        error: (e) => observer.error(e)
      });
      return () => {
        blockSub.unsubscribe();
        sourceSub?.unsubscribe();
      };
    });
  };
}

const getNewBlocks$ = (pinnedBlocks$) => pinnedBlocks$.pipe(
  rxjs.scan(
    ({ reportedBlocks: prevReportedBlocks }, { blocks }) => {
      const reportedBlocks = new Set(blocks.keys());
      const newBlocks = [];
      if (reportedBlocks.size > prevReportedBlocks.size) {
        blocks.forEach(({ hash, number, parent }) => {
          if (!prevReportedBlocks.has(hash)) {
            newBlocks.push({
              hash,
              number,
              parent
            });
          }
        });
      }
      return { reportedBlocks, newBlocks };
    },
    {
      reportedBlocks: /* @__PURE__ */ new Set(),
      newBlocks: new Array(0)
    }
  ),
  rxjs.mergeMap(({ newBlocks }) => newBlocks),
  rxjs.share()
);

const getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new rxjs.Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded > 0)
          observer.next(
            recoveralStorage$(
              hash,
              queries.slice(-nDiscarded),
              childTrie,
              true
            )
          );
      }
    )
  ).pipe(rxjs.mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

const createGetRuntimeChanges = (getCodeHash) => {
  const getRuntimeChanges = async (blocks, firstId, lastId) => {
    const firstBlock = blocks[firstId.idx];
    const lastBlock = blocks[lastId.idx];
    if (blocks.length === 2) return [firstBlock, lastBlock];
    const middleIdx = firstId.idx + Math.floor((lastId.idx - firstId.idx) / 2);
    const middle = {
      idx: middleIdx,
      id: await getCodeHash(blocks[middleIdx])
    };
    if (middle.id === firstId.id)
      return getRuntimeChanges(blocks, middle, lastId);
    if (middle.id === lastId.id)
      return getRuntimeChanges(blocks, firstId, middle);
    const [left, [_SKIP, ...right]] = await Promise.all([
      getRuntimeChanges(blocks, firstId, middle),
      getRuntimeChanges(blocks, middle, lastId)
    ]);
    return [...left, ...right];
  };
  return async (blocks) => {
    if (blocks.length < 2) return blocks;
    const lastIdx = blocks.length - 1;
    const [initialBlock] = blocks;
    const lastBlock = blocks[lastIdx];
    const [firstId, lastId] = await Promise.all(
      [initialBlock, lastBlock].map(getCodeHash)
    );
    if (firstId === lastId) return [blocks[0]];
    return getRuntimeChanges(
      blocks,
      { idx: 0, id: firstId },
      { idx: lastIdx, id: lastId }
    );
  };
};
const withInitializedNumber = (getHeader, getCodeHash) => {
  const getRuntimeChanges = createGetRuntimeChanges(getCodeHash);
  return (source$) => new rxjs.Observable((observer) => {
    let pending = null;
    return source$.subscribe({
      next(event) {
        if (event.type === "initialized") {
          pending = [];
          Promise.all([
            getHeader(event.finalizedBlockHashes[0]),
            getRuntimeChanges(event.finalizedBlockHashes)
          ]).then(([header, changes]) => {
            if (!observer.closed) {
              observer.next({
                type: "initialized",
                finalizedBlockHashes: event.finalizedBlockHashes,
                runtimeChanges: new Set(changes),
                number: header.number,
                parentHash: header.parentHash
              });
              pending.forEach((e) => {
                observer.next(e);
              });
              pending = null;
            }
          }).catch((e) => {
            if (!observer.closed) observer.error(e);
          });
        } else if (pending) pending.push(event);
        else observer.next(event);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
  });
};
const getFollow$ = (chainHead) => {
  let follower = null;
  let unfollow = rxjs.noop;
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getHeader = (hash) => getFollower().header(hash).then(substrateBindings.blockHeader.dec);
  const getCodeHash = async (blockHash) => (
    // ":code" => "0x3a636f6465"
    getFollower().storage(
      blockHash,
      "hash",
      "0x3a636f6465",
      null
    )
  );
  const follow$ = rxjs.connectable(
    new rxjs.Observable((observer) => {
      follower = chainHead(
        true,
        (e) => {
          observer.next(e);
        },
        (e) => {
          follower = null;
          observer.error(e);
        }
      );
      unfollow = () => {
        observer.complete();
        follower?.unfollow();
      };
    }).pipe(
      withInitializedNumber(getHeader, getCodeHash),
      retryChainHeadError()
    )
  );
  const startFollow = () => {
    follow$.connect();
    return () => {
      unfollow();
    };
  };
  return {
    getHeader,
    getFollower,
    startFollow,
    follow$
  };
};
const retryChainHeadError = () => (source$) => new rxjs.Observable((observer) => {
  const subscription = new rxjs.Subscription();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      subscription.add(subscribe());
      if (e instanceof substrateClient.StopError) {
        observer.next({ type: "stop-error" });
      } else {
        console.warn("ChainHead follow request failed, retrying\u2026", e);
      }
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

const withRecovery = (getHash) => (fn) => {
  const result = (...args) => {
    const hash = getHash();
    return hash ? fn(hash, ...args).pipe(
      rxjs.catchError((e) => {
        if (e instanceof BlockNotPinnedError) return result(...args);
        if (e instanceof substrateClient.OperationInaccessibleError)
          return rxjs.timer(750).pipe(rxjs.mergeMap(() => result(...args)));
        throw e;
      })
    ) : rxjs.EMPTY;
  };
  return result;
};
const getRuntimeCreator = (call$, getCodeHash$, getCachedMetadata, setCachedMetadata) => {
  const getMetadata$ = (codeHash$, rawMetadata$) => codeHash$.pipe(
    rxjs.mergeMap(
      (codeHash) => getCachedMetadata(codeHash).pipe(
        rxjs.catchError(() => rxjs.of(null)),
        rxjs.mergeMap(
          (metadataRaw) => metadataRaw ? rxjs.of(metadataRaw) : rawMetadata$.pipe(
            rxjs.tap((raw) => {
              setCachedMetadata(codeHash, raw);
            })
          )
        ),
        rxjs.map((metadataRaw) => ({
          codeHash,
          metadataRaw,
          metadata: substrateBindings.unifyMetadata(substrateBindings.metadata.dec(metadataRaw))
        }))
      )
    )
  );
  return (getHash) => {
    const enhancer = withRecovery(getHash);
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const codeHash$ = enhancer(getCodeHash$)().pipe(rxjs.shareReplay(1));
    const runtimeContext$ = getMetadata$(
      codeHash$,
      getRawMetadata$(enhancer(call$))
    ).pipe(
      rxjs.map(
        ({ metadata, metadataRaw, codeHash }) => createRuntimeCtx(metadata, metadataRaw, codeHash)
      ),
      rxjs.shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      codeHash$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

const createRuntimeGetter = (pinned, startAt) => {
  return () => {
    const runtime = pinned.runtimes[startAt];
    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null;
    const winner = [...runtime.usages].at(-1);
    return winner ?? null;
  };
};
const deleteBlock = (blocks, blockHash) => {
  blocks.get(blocks.get(blockHash).parent)?.children.delete(blockHash);
  blocks.delete(blockHash);
};
const deleteBlocks = (blocks, toDelete) => {
  toDelete.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value]) => ({
    key,
    usages: value.deleteBlocks(toDelete)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
};
const getPinnedBlocks$ = (follow$, call$, getCodeHash$, getCachedMetadata$, setCachedMetadata, blockUsage$, onUnpin, deleteFromCache) => {
  const cleanup$ = new rxjs.Subject();
  const cleanupEvt$ = cleanup$.pipe(
    rxjs.exhaustMap(() => rxjs.timer(0)),
    rxjs.map(
      () => ({
        type: "cleanup"
      })
    )
  );
  const pinnedBlocks$ = rxjs.merge(
    blockUsage$,
    cleanupEvt$,
    follow$
  ).pipe(
    rxjs.scan((acc, event) => {
      const unpinAndDelete = (toUnpin) => {
        deleteBlocks(acc, toUnpin);
        onUnpin(toUnpin);
      };
      switch (event.type) {
        case "initialized":
          if (acc.recovering && !event.finalizedBlockHashes.some((hash) => acc.blocks.has(hash)))
            acc = getInitialPinnedBlocks();
          const lastIdx = event.finalizedBlockHashes.length - 1;
          acc.finalized = acc.best = event.finalizedBlockHashes[lastIdx];
          let latestRuntime = acc.finalizedRuntime.at;
          event.finalizedBlockHashes.forEach((hash, i) => {
            const unpinnable = i !== lastIdx;
            const preexistingBlock = acc.blocks.get(hash);
            if (preexistingBlock) {
              preexistingBlock.recovering = false;
              preexistingBlock.unpinnable = unpinnable;
            } else {
              const isNewRuntime = event.runtimeChanges.has(hash);
              if (isNewRuntime) latestRuntime = hash;
              acc.blocks.set(hash, {
                hash,
                parent: i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1],
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                unpinnable,
                runtime: latestRuntime,
                refCount: 0,
                number: event.number + i,
                recovering: false
              });
              if (isNewRuntime)
                acc.finalizedRuntime = acc.runtimes[hash] = getRuntime(
                  createRuntimeGetter(acc, hash)
                );
              acc.runtimes[latestRuntime].usages.add(hash);
            }
          });
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            const block = {
              hash,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              unpinnable: false,
              refCount: 0,
              recovering: false
            };
            acc.blocks.set(hash, block);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash));
            }
            acc.runtimes[block.runtime].addBlock(hash);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
                deleteFromCache(hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          event.prunedBlockHashes.forEach((hash) => {
            const block = acc.blocks.get(hash);
            if (block) {
              block.unpinnable = true;
            }
          });
          let current = blocks.get(blocks.get(acc.finalized).parent);
          while (current && !current.unpinnable) {
            current.unpinnable = true;
            current = blocks.get(current.parent);
          }
          cleanup$.next();
          return acc;
        }
        case "cleanup": {
          const toUnpin = [...acc.blocks.values()].filter(({ unpinnable, refCount }) => unpinnable && !refCount).map(({ hash }) => hash);
          unpinAndDelete(toUnpin);
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash)) return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && !block.recovering && block.unpinnable) {
            const toUnpin = [block.hash];
            unpinAndDelete(toUnpin);
          }
          return acc;
        }
      }
    }, getInitialPinnedBlocks()),
    rxjs.filter((x) => !!x.finalizedRuntime.runtime),
    rxjs.map((x) => ({ ...x })),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks"),
    withStopRecovery(pinnedBlocks$, getCodeHash$, "pinned-blocks"),
    getCachedMetadata$,
    setCachedMetadata
  );
  return pinnedBlocks$;
};
const getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});

const getTrackTx = (blocks$, getBody, getIsValid, getEvents) => {
  const whileBlockPresent = (hash) => rxjs.takeUntil(blocks$.pipe(rxjs.filter(({ blocks }) => !blocks.has(hash))));
  const analyzeBlock = (hash, tx, alreadyPresent) => {
    if (alreadyPresent)
      return rxjs.of({ hash, found: { type: false, validity: null } });
    const whilePresent = whileBlockPresent(hash);
    return getBody(hash).pipe(
      rxjs.mergeMap((txs) => {
        const index = txs.indexOf(tx);
        return index > -1 ? whilePresent(getEvents(hash)).pipe(
          rxjs.map((events) => ({
            hash,
            found: {
              type: true,
              index,
              events
            }
          }))
        ) : getIsValid(hash, tx).pipe(
          rxjs.map((validity) => ({
            hash,
            found: { type: false, validity }
          }))
        );
      }),
      whilePresent
    );
  };
  const findInBranch = (hash, tx, alreadyPresent) => analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(
    rxjs.mergeMap((analyzed) => {
      const { found } = analyzed;
      return found.type || found.validity?.success === false ? rxjs.of(analyzed) : blocks$.pipe(
        whileBlockPresent(hash),
        rxjs.mergeMap((x) => x.blocks.get(hash).children),
        rxjs.distinct(),
        rxjs.mergeMap((hash2) => findInBranch(hash2, tx, alreadyPresent))
      );
    })
  );
  return (tx) => blocks$.pipe(
    rxjs.take(1),
    rxjs.mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys())))
  );
};

const external = new Uint8Array([2]);
const getValidateTxArgs = (tx, hash) => utils.toHex(utils.mergeUint8([external, utils.fromHex(tx), utils.fromHex(hash)]));
const TaggedTransactionQueue = "TaggedTransactionQueue";
const validateTransaction = "validate_transaction";
const [, defaultInvalidTxDecoder] = substrateBindings.Variant({
  InvalidTransaction: substrateBindings.Variant({
    Call: substrateBindings._void,
    Payment: substrateBindings._void,
    Future: substrateBindings._void,
    Stale: substrateBindings._void,
    BadProof: substrateBindings._void,
    AncientBirthBlock: substrateBindings._void,
    ExhaustsResources: substrateBindings._void,
    Custom: substrateBindings.u8,
    BadMandatory: substrateBindings._void,
    MandatoryValidation: substrateBindings._void,
    BadSigner: substrateBindings._void
  }),
  UnknownTransaction: substrateBindings.Variant({
    CannotLookup: substrateBindings._void,
    NoUnsignedValidator: substrateBindings._void,
    Custom: substrateBindings.u8
  })
});
const defaultValidateTxDecoder = substrateBindings.createDecoder((input) => {
  const firstByte = substrateBindings.u8.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value;
  try {
    value = defaultInvalidTxDecoder(input);
  } catch (_) {
    value = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value };
});
const getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    rxjs.map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    rxjs.withLatestFrom(decoder$),
    rxjs.map(([result, decoder]) => decoder(result))
  );
};

const toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
const getChainHead$ = (chainHead, getCachedMetadata, setCachedMetadata) => {
  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new rxjs.Subject();
  const usingBlock = (hash) => (base) => new rxjs.Observable((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = base.subscribe(observer);
    subscription.add(() => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    });
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new rxjs.Observable((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(rxjs.take(1)).subscribe((blocks) => {
      isPresent = blocks.blocks.has(hash);
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label));
  });
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof substrateClient.DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => withInMemory(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        withRecoveryFn(fromAbortControllerFn(fn)),
        `stop-${label}`
      )
    ),
    label
  );
  const cache = /* @__PURE__ */ new Map();
  const stg = withRefcount(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("storage")))
  );
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    stg(blockHash, "hash", "0x3a636f6465", null).pipe(rxjs.map((x) => x))
  );
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    getCodeHash,
    getCachedMetadata,
    setCachedMetadata,
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withInMemory(
    withRefcount(
      (hash) => pinnedBlocks$.pipe(
        rxjs.take(1),
        rxjs.mergeMap(
          (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
        )
      )
    ),
    "getRuntimeCtx"
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(rxjs.map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      rxjs.share({
        connector: () => connector = new rxjs.ReplaySubject()
      }),
      rxjs.tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    rxjs.filter((x) => !x.recovering),
    rxjs.distinctUntilChanged((a, b) => a.finalized === b.finalized),
    rxjs.scan((acc, value) => {
      let current = value.blocks.get(value.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    rxjs.mergeAll(),
    rxjs.map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    rxjs.distinctUntilChanged((a, b) => a.best === b.best),
    rxjs.map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    rxjs.filter((x) => !x.recovering),
    rxjs.distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    rxjs.scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    rxjs.map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    rxjs.distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    rxjs.switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(rxjs.map((x) => x?.lookup.metadata ?? null));
  const withOptionalHash$ = getWithOptionalHash$(
    finalized$.pipe(rxjs.map((b) => b.hash)),
    best$.pipe(rxjs.map((b) => b.hash)),
    usingBlock
  );
  const _body$ = commonEnhancer(lazyFollower("body"), "body");
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    withInMemory(
      (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
        rxjs.take(1),
        rxjs.mergeMap(
          (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
        ),
        rxjs.mergeMap((ctx) => {
          const key = keyMapper(ctx);
          return upsertCachedStream(
            hash,
            `storage-${type}-${key}-${childTrie ?? ""}`,
            _storage$(hash, type, key, childTrie)
          ).pipe(mapper ? rxjs.map((raw) => mapper(raw, ctx)) : rxjs.identity);
        })
      ),
      "storage"
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(
        pinnedBlocks$,
        (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
        `storageQueries`
      ),
      "storageQueries"
    )
  );
  const header$ = withOptionalHash$(
    withInMemory(
      withStopRecovery(
        pinnedBlocks$,
        (hash) => rxjs.defer(() => getHeader(hash)),
        "header"
      ),
      "header"
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, fn, args) => upsertCachedStream(hash, `call-${fn}-${args}`, __call$(hash, fn, args))
  );
  const validateTx$ = getValidateTx(call$, getRuntimeContext$);
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => rxjs.of()
  );
  const genesis$ = runtime$.pipe(
    rxjs.filter(Boolean),
    rxjs.take(1),
    rxjs.mergeMap((runtime) => {
      const { enc } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc(0);
      } catch {
        key = enc(0n);
      }
      return storage$(null, "value", () => key, null);
    }),
    rxjs.shareReplay(1)
  );
  rxjs.merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  let unfollow = rxjs.noop;
  let started = false;
  let nSubscribers = 0;
  const start = (_nSubscribers) => {
    nSubscribers += _nSubscribers;
    started = true;
    unfollow = startFollow();
  };
  const getRuntime$ = (codeHash) => pinnedBlocks$.pipe(
    rxjs.take(1),
    rxjs.mergeMap(
      ({ runtimes }) => rxjs.merge(
        ...Object.values(runtimes).map(
          (runtime) => runtime.codeHash$.pipe(
            rxjs.mergeMap(
              (_codehash) => codeHash === _codehash ? runtime.runtime : rxjs.EMPTY
            )
          )
        )
      ).pipe(rxjs.endWith(null), rxjs.take(1))
    )
  );
  const holdBlock = (blockHash, shouldThrow = false) => {
    let hash = blockHash || "finalized";
    let isPresent = false;
    started && pinnedBlocks$.pipe(rxjs.take(1)).subscribe((blocks) => {
      hash = blocks[hash] || hash;
      isPresent = blocks.blocks.has(hash);
    });
    if (!isPresent) {
      if (shouldThrow) throw new BlockNotPinnedError(hash, "holdBlock");
      return rxjs.noop;
    }
    blockUsage$.next({
      type: "blockUsage",
      value: {
        type: "hold",
        hash
      }
    });
    let tearDown = () => {
      blockUsage$.next({
        type: "blockUsage",
        value: {
          type: "release",
          hash
        }
      });
      tearDown = rxjs.noop;
    };
    return () => {
      tearDown();
    };
  };
  const withHodl = (blockHash) => (base) => new rxjs.Observable((observer) => {
    const subscription = base.subscribe(observer);
    if (!subscription.closed) subscription.add(holdBlock(blockHash));
    return subscription;
  });
  return [
    {
      follow$,
      finalized$,
      best$,
      bestBlocks$,
      newBlocks$: getNewBlocks$(pinnedBlocks$),
      runtime$,
      metadata$,
      genesis$,
      getRuntime$,
      header$,
      body$,
      call$,
      storage$,
      storageQueries$,
      eventsAt$,
      withHodl,
      holdBlock,
      trackTx$,
      trackTxWithoutEvents$,
      validateTx$,
      pinnedBlocks$,
      withRuntime,
      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
      unfollow: () => {
        if (started == null) return;
        nSubscribers--;
        if (started && !nSubscribers) {
          started = null;
          unfollow();
          unfollow = rxjs.noop;
        }
      }
    },
    start
  ];
};

var getBroadcastTx$ = (baseTransaction) => (transaction) => new rxjs.Observable(
  (observer) => baseTransaction(transaction, (e) => {
    observer.error(e);
  })
);

const getArchive = ({ storageSubscription, ...archive }) => (getRuntime) => {
  const runtimes = {};
  const rawStorage$ = fromAbortControllerFn(archive.storage);
  const call$ = fromAbortControllerFn(archive.call);
  const rawHeader$ = fromAbortControllerFn(archive.header);
  const body$ = fromAbortControllerFn(archive.body);
  const header$ = (blockHash) => rawHeader$(blockHash).pipe(rxjs.map(substrateBindings.blockHeader[1]));
  const getCodeHash = (blockHash) => (
    // ":code" => "0x3a636f6465"
    rawStorage$(blockHash, "hash", "0x3a636f6465", null).pipe(rxjs.map((x) => x))
  );
  const getRuntime$ = (codeHash, blockHash) => getRuntime(codeHash).pipe(
    rxjs.catchError(() => rxjs.of(null)),
    rxjs.mergeMap(
      (result) => result ? rxjs.of(result) : getRawMetadata$((...args) => call$(blockHash, ...args)).pipe(
        rxjs.map(
          (rawMetadata) => createRuntimeCtx(
            substrateBindings.unifyMetadata(substrateBindings.metadata.dec(rawMetadata)),
            rawMetadata,
            codeHash
          )
        )
      )
    ),
    rxjs.tap((runtime) => {
      runtimes[codeHash] = runtime;
    })
  );
  const getRuntimeContext$ = (blockHash) => getCodeHash(blockHash).pipe(
    rxjs.mergeMap((codeHash) => {
      const runtime = runtimes[codeHash];
      return runtime ? rxjs.of(runtime) : getRuntime$(codeHash, blockHash);
    })
  );
  const storage$ = (hash, type, keyMapper, childTrie = null, mapper) => getRuntimeContext$(hash).pipe(
    rxjs.mergeMap(
      (ctx) => rawStorage$(hash, type, keyMapper(ctx), childTrie).pipe(
        rxjs.map((x) => mapper ? mapper(x, ctx) : x)
      )
    )
  );
  const storageQueries$ = (hash, queries, childTrie) => new rxjs.Observable(
    (observer) => storageSubscription(
      hash,
      queries,
      childTrie || null,
      (item) => observer.next(item),
      (error) => observer.error(error),
      () => {
        observer.complete();
      }
    )
  );
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  return {
    body$,
    header$,
    storage$,
    storageQueries$,
    call$,
    eventsAt$,
    getRuntimeContext$
  };
};

const ofNullFn = () => rxjs.of(null);
const clientCache = /* @__PURE__ */ new Map();
const getObservableClient = (substrateClient, cache = {}) => {
  const { getMetadata, setMetadata } = cache;
  const cached = clientCache.get(substrateClient);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const destroy = () => {
    const cached2 = clientCache.get(substrateClient);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache.delete(substrateClient);
      substrateClient.destroy();
    } else {
      cached2.refCount--;
    }
  };
  let cachedChainhead = null;
  let currentSubscribers = 0;
  let expectedSubscribers = null;
  const client = {
    chainHead$: (_expectedSubscribers) => {
      currentSubscribers++;
      expectedSubscribers || (expectedSubscribers = _expectedSubscribers || 1);
      cachedChainhead || (cachedChainhead = getChainHead$(
        substrateClient.chainHead,
        getMetadata || ofNullFn,
        setMetadata || rxjs.noop
      ));
      const [result, start] = cachedChainhead;
      if (expectedSubscribers === currentSubscribers) {
        const copiedCurrentSubscribers = currentSubscribers;
        currentSubscribers = 0;
        expectedSubscribers = null;
        cachedChainhead = null;
        start(copiedCurrentSubscribers);
      }
      return result;
    },
    archive: getArchive(substrateClient.archive),
    broadcastTx$: getBroadcastTx$(substrateClient.transaction),
    destroy
  };
  clientCache.set(substrateClient, { client, refCount: 1 });
  return client;
};

const isBestOrFinalizedBlock = (blocks$, blockHash) => blocks$.pipe(
  rxjs.takeWhile((b) => b.blocks.has(blockHash)),
  rxjs.distinctUntilChanged(
    (a, b) => a.finalized === b.finalized && a.best === b.best
  ),
  rxjs.map((pinned) => {
    if (pinned.blocks.get(blockHash).number > pinned.blocks.get(pinned.best).number)
      return null;
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized = isFinalized || pinned.finalized === current.hash;
    }
    if (isFinalized) return "finalized";
    return current.hash === blockHash ? "best" : null;
  }),
  rxjs.distinctUntilChanged(),
  rxjs.takeWhile((x) => x !== "finalized", true)
);

const withArchive = (chainHeadFn, archiveFn) => (blokHash, ...args) => chainHeadFn(blokHash, ...args).pipe(
  rxjs.catchError((e) => {
    if (!(e instanceof BlockNotPinnedError)) throw e;
    return archiveFn(blokHash, ...args).pipe(
      rxjs.catchError((actualErr) => {
        console.warn(actualErr);
        throw e;
      })
    );
  })
);

exports.BlockNotPinnedError = BlockNotPinnedError;
exports.concatMapEager = concatMapEager;
exports.getObservableClient = getObservableClient;
exports.isBestOrFinalizedBlock = isBestOrFinalizedBlock;
exports.withArchive = withArchive;
//# sourceMappingURL=index.js.map
